#!/usr/bin/env python3

import argparse
import io
import socket
import tempfile
import threading
from pathlib import Path

import gi
import zmq
import zmq.auth
import zmq.auth.thread
from PIL import Image

gi.require_version('Notify', '0.7')

from gi.repository import Notify


def start():
    main_directory = Path(Path.home(), ".a2ln")

    client_public_keys_directory = main_directory / "clients"
    server_keys_directory = main_directory / "server"

    main_directory.mkdir(exist_ok=True)

    client_public_keys_directory.mkdir(exist_ok=True)

    if not server_keys_directory.exists():
        server_keys_directory.mkdir()

        zmq.auth.create_certificates(server_keys_directory, "server")

    ip = get_ip()

    public_key, secret_key = zmq.auth.load_certificate(server_keys_directory / "server.key_secret")

    port = parse_args().port

    notification_server = NotificationServer(client_public_keys_directory, public_key, secret_key, ip, port)
    pair_server = PairServer(client_public_keys_directory, public_key, ip, port, notification_server)

    for server in [pair_server, notification_server]:
        server.start()

    try:
        while True:
            pass
    except KeyboardInterrupt:
        print("\nBye!")

        exit()


def parse_args():
    argument_parser = argparse.ArgumentParser(description="A way to display Android phone notifications on Linux")

    argument_parser.add_argument("port", metavar="p", type=int, help="The port")

    return argument_parser.parse_args()


def get_ip():
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client:
        client.connect(("8.8.8.8", 80))

        return client.getsockname()[0]


def send_notification(title, text, picture_file=None):
    if picture_file is None:
        Notify.Notification.new(title, text, "dialog-information").show()
    else:
        Notify.Notification.new(title, text, picture_file.name).show()

        picture_file.close()

    print(f"Sent notification (Title: {title}, Text: {text}).")


class NotificationServer(threading.Thread):
    def __init__(self,
                 client_public_keys_directory,
                 server_public_key,
                 server_secret_key,
                 server_ip,
                 server_notification_port):
        super().__init__(daemon=True)

        self.client_public_keys_directory = client_public_keys_directory
        self.server_public_key = server_public_key
        self.server_secret_key = server_secret_key
        self.server_ip = server_ip
        self.server_notification_port = server_notification_port
        self.authenticator = None

    def run(self) -> None:
        super(NotificationServer, self).run()

        with zmq.Context() as context:
            self.authenticator = zmq.auth.thread.ThreadAuthenticator(context)

            self.authenticator.start()

            self.update_client_keys()

            with context.socket(zmq.PULL) as server:
                server.curve_publickey = self.server_public_key
                server.curve_secretkey = self.server_secret_key

                server.curve_server = True

                try:
                    server.bind(f"tcp://*:{self.server_notification_port}")
                finally:
                    self.authenticator.stop()

                print(f"Notification server running on host {self.server_ip} and port {self.server_notification_port}.")

                while True:
                    request = server.recv_multipart()

                    length = len(request)

                    if length != 2 and length != 3:
                        continue

                    if length == 3:
                        picture_file = tempfile.NamedTemporaryFile(suffix=".png")

                        Image.open(io.BytesIO(request[2])).save(picture_file.name)
                    else:
                        picture_file = None

                    threading.Thread(target=send_notification,
                                     args=(request[0].decode("utf-8"), request[1].decode("utf-8"), picture_file),
                                     daemon=True).start()

    def update_client_keys(self):
        if self.authenticator is not None and self.authenticator.is_alive():
            self.authenticator.configure_curve(domain="*", location=self.client_public_keys_directory.as_posix())


class PairServer(threading.Thread):
    def __init__(self,
                 client_public_keys_directory,
                 server_public_key,
                 server_ip,
                 server_notification_port,
                 notification_server):
        super(PairServer, self).__init__(daemon=True)

        self.client_public_keys_directory = client_public_keys_directory
        self.server_public_key = server_public_key
        self.server_ip = server_ip
        self.server_notification_port = server_notification_port
        self.notification_server = notification_server

    def run(self):
        super(PairServer, self).run()

        with zmq.Context() as context, context.socket(zmq.REP) as server:
            server.setsockopt(zmq.LINGER, 1)

            server_pairing_port = server.bind_to_random_port("tcp://*")

            print(f"Pairing server running on host {self.server_ip} and port {server_pairing_port}.")

            while True:
                request = server.recv_multipart()

                if len(request) != 2:
                    continue

                client_ip = request[0].decode("utf-8")
                client_public_key = request[1].decode("utf-8")

                print("")
                print("New pairing request")
                print("")
                print("Client IP: " + client_ip)
                print("Client public key: " + client_public_key)
                print("")
                print("Your IP: " + self.server_ip)
                print("Your public key: " + self.server_public_key.decode("utf-8"))
                print("")

                if input("Accept? (Yes/No): ").lower() != "yes":
                    print("Pairing cancelled.")

                    server.send_multipart([b""])

                    continue

                with open(self.client_public_keys_directory / client_ip, "w", encoding="utf-8") as client_key_file:
                    client_key_file.write("metadata\n"
                                          "curve\n"
                                          f"    public-key = \"{client_public_key}\"\n")

                server.send_multipart([str(self.server_notification_port).encode("utf-8"), self.server_public_key])

                self.notification_server.update_client_keys()

                print("Pairing finished.")


start()
